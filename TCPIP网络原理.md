#  TCP/IP网络原理

#  一，自定义应用层协议

如何进行自定义协议：1，考虑客户端，服务器之间传输哪些信息。2，考虑信息，数据按照什么格式来进行组织。

***

如果是自定义应用层协议的话，那么就会很灵活，每个人可能都定义的不一样，我们常说，在编程里面，我们是不喜欢灵活的。所以，很多大佬们给我们发明了一些规定好的协议格式，我们可以直接用，这样就会更规范，更通用。

***

1，HTTP协议(这里不具体介绍，后续会深入学习)

***

2，XML

XML是一种比较经典的数据组织格式，现在不过用的没有那么多了。它是使用标签的形式来组织键值对数据的。

```xml
<request>
    <name>
        aaa
    </name>
</request>
```

***

对于XML,存在一些缺点：首先代码可观性不强，当数据量大的情况下，会很复杂，另外因为使用了大量的标签，在进行网络传输的时候，也会占用比较多的带宽。

***

3，json

json是当前最流行的一种数据组织格式。json用{}来包裹数据键值对，其中键只能是字符串，值可以是字符串，数字，数组，json。

```json
{
    position:{
        province:HuBei
    }
    name:["小明","小李"]
}
```

json相对于XM，代码可观性就好了很多，可扩展性也比较强。但是同理，因为引入了额外的字符串，所以也会占用带宽，效率也是会降低。

***

4，protobuffer

相对于XML,json，这种格式组织的数据，占用空间会更低一些，所以占用带宽的就不会很高，数据传输效率会更高。但是，它是一个二进制的格式，所以就不太利于人去观察了。

***

#  二，传输层

传输层关注端到端

##  2.1，UDP协议

![image-20221018110717281](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221018110717281.png) 

***

可以看到，一个UDP数据报的报文长度最大是64kb,64kb放在以前可能很大，但是在现在，64kb很小。所以在使用UDP传输一个较大的数据时，就需要考虑进行拆包了，把一个很大的数据拆分成很多小的数据报。

***

数据太大的解决方法：

1，在应用层程序里面，针对数据进行拆包，然后分别进行传输。但是这样开发起来比较麻烦，并且也有一定的风险。

2，使用TCP进行传输，因为TCP是针对字节流的，没有对数据报的长度进行限制。这是最好的解决办法。

***

【校验和的作用：】

作用是检查数据是否出错。在数据进行传输的时候，都是光信号或者是电信号，就会容易受到外界比如强电场，磁场之类的环境的影响，那我们就需要在接收到数据之后检查一下这个数据有没有出现错误。

***

![image-20221018113843834](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221018113843834.png) 

***

##  2.2，TCP协议(重点)

###   2.2.1，报文结构

![image-20221018141436419](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221018141436419.png) 

***

###  2.2.2，TCP特性

TCP的特性：有连接，可靠传输（核心），面向字节流，全双工。对于有连接，面向字节流，全双工(针对一个Socket对象既可以读，也可以写)在代码里面都是体现出来的了。但是对于可靠传输这一点，代码中是看不出来的。

***

###  2.2.3，TCP可靠传输机制

#### 1,确认应答机制

![image-20221018182709023](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221018182709023.png) 

***

![image-20221018182739313](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221018182739313.png) 

***

【补充：】

这里补充说明一下一个小细节，就是应答报文ack和响应是两个不同的东西。ack是系统内核在收到请求之后返回给发送方的，这只是一个单纯的反馈表示我收到了你的数据了；但是响应是业务上根据请求做出的反馈，这是应用程序负责的。

***

####  2，超时重传机制

在现实网络环境中，中间可能某个设备的转发能力是有上限的，如果数据量太多造成网络拥堵，那么就很可能有的数据会丢包，那么接收方也就无法正常的接收到一些本该接收到的数据了。

那么既然数据丢包了，我们进行重传就好了。

***

这里的丢包存在两种情况，一种是数据报丢了，还有一种可能是ACK丢了。

![image-20221019140930870](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221019140930870.png) 

***

那这里又涉及到一个问题了，我们的这个特定的时间间隔，也就是超时时间，怎么确定。

一般在我们的系统里，会有一个配置项描述超时时间的阈值，超时时间并不是每次都均等的，而是在动态的进行增长。

例如，如果第一次出现丢包，超过阈值后进行重发，如果重发之后还是没有收到确认应答(小概率事件还是发生了)，那么就会再次进行重发，只不过第二次重发的超时时间阈值一般是要比第一次长的。如果当前网络环境真的非常非常差，这样的重传了几次都没有结果，那么就会重置TCP连接进行重连，如果重连直接连不上了或者一样没有任何作用的话，那就释放连接彻底放弃了。

【这里主要是学习策略，不要去刻意纠结比如一般时间间隔是多少，每次阈值增加多少，以及重传多少次之后进行重连，这些都是各个系统内定义的，不用过度关注这些数字】

***

####  3，连接管理机制

描述的是TCP建立连接与断开连接的中间具体过程。这里我们所说的连接是一种虚拟的连接，而不是物理上的连接。进行网络通信，你物理上的连接肯定是连接好的，虚拟连接就是指双方知道自己是在和谁通信，对方IP,端口号，使用协议等等，这些在各自主机上都有数据结构进行保存。

***

**1，建立连接(双方建立一个相互认同的关系)**

三次握手的机制：(只能是客户端先发起)

![image-20221019152247160](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221019152247160.png) 

***

三次握手的作用：

1，探测传输线路是否正常(投石问路)

因为我们的同步报文段还是应答报文段也都是需要走我们的网络线路的，通过我们的三次握手就可以探测出基本的线路是不是正常的，如果三次握手的数据都不能正常的进行传输，那么数据就更不用说了。

***

2，检测双方的接收，发送的功能是否正常

![image-20221019154302963](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221019154302963.png) 

***

这三次握手交互，少了哪一次测试都是不完整的。

***

3，在握手过程中，也在协商一些重要的参数。

TCP中的很多参数都是需要进行协商的，比如我们的序号，并不是每次都是从1开始的，通常都是建立连接的时候协商了一个数字，这样可以来区分不同的连接。

***

两个重要的TCP状态：

1，LISTEN :表示服务器已经启动好了，也绑定了端口，可以进行连接。

2，ESTABLISHED :表示连接之后的稳定状态。

***

**2，断开连接(双方断开相互认同的关系)**

四次挥手的机制：通信双方各自请求与对方断开连接，再各自给对方回应。(可以是客户端先发起，也可以是服务器先发起)

![image-20221019165628373](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221019165628373.png) 

***

两个重要的TCP状态：

![image-20221019171157935](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221019171157935.png) 

***

###  2.2.4，TCP效率机制

####  1，滑动窗口机制

滑动窗口机制：我们知道，TCP为了提高可靠性，每次都需要等待ACK的确认应答，所以整体的效率会很低。那么滑动窗口机制就是在保证可靠性的基础之上，提出的一种可以尽可能提高效率的机制。当然这里的提高只能说是亡羊补牢，要比效率TCP不可能高得过UDP。

![image-20221020142518400](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020142518400.png) 

***

【滑动窗口演示：】

![image-20221020142613218](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020142613218.png)  

***

对于我们的滑动窗口，窗口越大，效率也就越高，窗口越小。效率也就越低。如果我们的窗口是无穷大，那么就相当于不需要等待任何请求到应答，也就是相当于UDP了。但是实际窗口是不可能为无穷大的。

***

下面来介绍下滑动窗口是如何解决丢包，以及乱序的问题的。

**(1)，丢包问题**

1，ack丢了，数据报都正常到达。

![image-20221020150127971](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020150127971.png) 

***

2，数据报直接丢了。

![image-20221020151901346](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020151901346.png) 

***

这一种重传机制中，就只对丢了的数据报进行重传，并且每次发送数据不需要等待ack的缘故，所以这种重传的方式还是很高效的，这种方式叫做快速重传。

之前我们还学过一个超时重传，这两种重传的机制之间是一个相互配合的关系。当数据量很多的时候，自然是利用快速重传效率更高，但是如果数据量很少，比如就一条，那么采用超时重传就好。比如如果是最后一条数据丢了，那么肯定是利用超时重传来解决的。

超时重传是一直得等到过了时间阈值才会进行重传，中间时间间隔相对较久。但是快速重传不需要可以关注过了多长时间，只要是收到了多次相同的ack应答就知道是数据丢了就进行重传，速度会更快。

***

####   2，流量控制机制

我们前面说，窗口的大小不可能是无穷大，因为那就意味着发送方会一直发送数据，发送发一直发送数据，那你还得考虑一下接收方的接受能力，接收方接受不下了就会对一些数据进行丢弃，那就会造成丢包，丢包了发送方又会重发，那对于接收方来说就是雪上加霜，所以我们在滑动窗口的机制之前，还需要对于发送速率进行一些限制，也就是限制窗口不能太大。

***

那么发送方如何来量化这个合适的窗口大小的值呢？答案在接收方身上，接收方会根据自身的接收能力，来反向的影响发送方的发送速率。

![image-20221020163902227](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020163902227.png) 

***

【具体过程：】

![image-20221020164638723](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020164638723.png) 

***

####  3，拥塞控制机制

![image-20221020171559779](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020171559779.png) 

***

既然流量控制和拥塞控制都是在控制发送方的窗口大小，那么这两个值到底最后谁来决定窗口大小呢？我们也都知道木桶原理，所以肯定是取决于这两个值中最小的那一个，只有这样才能兼顾到中间节点和接收方。

***

![image-20221020183738912](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221020183738912.png) 

***

上述的这个过程，是TCP传统的拥塞控制的实现。但是，随着后来TCP的演化，也作出了一些优化，比如出现丢包之后拥塞窗口的值不会直接回归到初始值，而是中间的一个合适的值。这样就不会造成传输速率的一个陡然下降。

***

####  4，延时应答机制

延时应答机制是基于流量控制引入的提高效率的机制。

****

![image-20221021105453122](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021105453122.png) 

***

注意这个是基于流量控制的基础之上的，可以保证在你延迟应答的那段时间内，发送方的窗口大小是合适的，不会说因为你延迟了这一会儿没有去及时的调整窗口大小，然后发送方就因为发的数据太多了而导致的丢包等问题。

不过注意，也不是所有的包都会延时应答，一般是选择n个包就延时应答一次或者说超过最大延时时间就延时应答一次。这个具体的数量和超时时间，不同的系统有不同的设定。

***

####  5，捎带应答机制

捎带应答又是基于延时应答的基础上实现的。

![image-20221021112011083](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021112011083.png) 

****

捎带应答的发生是能说是一个偶然发生的事情，只是刚好两个时机凑到了一起。前面所说的四次回收可能中间会合并也就是说的这个可能。

***

###  2.2.5，面向字节流

####  1，粘包问题

***

![image-20221021131622261](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021131622261.png) 

***

对于UDP是没有这个问题的，因为它的一条数据都自己对应一个数据报，所以不会有这种问题。那么TCP的这种粘包问题怎么解决呢？其实主要的问题是出在我们在应用层组织数据的时候没有给出明确的边界，所以解决方法就是在定义应用层协议的时候，明确好各个不同的数据包之间的边界就好了。

***

典型的办法有两种：

1，确定分隔符。约定使用什么分隔符来对各个数据包进行分割。

2，使用长度限定。在数据包的开头处声明这个数据包的长度。

***

自定义应用层协议中的具体实现可以依据现成的数据格式：

1，xml中分隔符就相当于</>结束标签。

2，json分割符就相当于 }

3，protobuffer是通过声明长度来标记边界的。

4，http中是分隔符和声明长度配合使用。

***

###  2.2.6，TCP中的异常情况

####  1，程序崩溃

程序崩溃了也就是进程异常退出，这个时候操作系统会回收进程的相关资源，比如文件描述符，那么这样的一个操作就相当于是在调用Socket的close()的方法，也就是要断开这两个主机之间关于这个进程之间的通信，这个时候内核也会发送结束报文FIN,所以两个主机之间会正常的进入四次挥手的步骤。所以其实这里是不会有任何的问题的。

***

####  2，主机正常关机

主机在关机之前，其实会强制性的结束所有的进程，然后就会对文件描述符进行释放，进而通过内核发送FIN报文，正常的进入四次挥手的步骤。

***

####  3，主机掉电(突然断电不正常关机)

主机掉电这里有两种情况，可能是发送方的主机突然掉电，也可能是接收方的主机突然掉电。

(1)接收方主机掉电

当接收方的主机掉电之后，那么发送方此时发送的请求就没有ack了，然后过了超时时间就进行超时重传，重传几次，那同样肯定还是没有ack，发送方就会尝试重新建立连接(发送一个复位报文段)，照样还是会失败，此时发送方就会放弃就直接释放连接了。TCP报头中的标志位中有一个RST，当它为1的时候就是复位报文段。

(2)发送方主机掉电

发送方主机掉电之后，那这个时候接收方就接收不到数据了，那对于接收方而言，肯定也不能一直干等着，在等了一阵之后，就会发送一个“心跳包”，这个心跳包不包含任何业务层面上的内容，它的作用就只是检测一下对方还在不在。如果这个时候发送方不给接收方回发一个心跳包，那么接收方就知道是发送方挂了，进而就直接放弃连接了。

***

####  4，网络断开

网线断开的情况同主机掉电，只不过此处主机都是正常的，接收方和发送方分别走上述的两种情况。

***

##  2.3，TCP/UDP区别

除了我们前面所说的几个基础特性，我们需要知道TCP/UDP各自的应用场景。TCP适用于对数据可靠性要求高的场景，而UDP适用于对数据传输速率要求高而数据可靠性要求不高的场景。对于传输层也有其他的一些协议，能够同时保证可靠性与传输速率。

***

【面试题：如何实现UDP的可靠传输？】

其实这个问题看似是在考察UDP，其实是在考察你的TCP保证可靠传输的方式，只不过这里要你把它引用到UDP中即可，传输层的UDP肯定是实现不了可靠传输的，所以我们只能在应用层通过一些方法来模拟TCP的可靠传输机制。例如可以引入确认应答机制，超时重传机制，引入序列号等等【确认应答和超时重传是重点】。

***

#  三，网络层

##  3.1，IP协议

【报文结构：】

![image-20221021204004397](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021204004397.png) 

***

【各个部分介绍：】

![image-20221021204114572](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021204114572.png) 

***

![image-20221021204227168](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021204227168.png) 

***

![image-20221021204323240](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20221021204323240.png) 

