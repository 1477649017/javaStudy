#  搜索与图论

#  DFS&BFS

> DFS：深度优先搜索
>
> BFS：宽度优先搜索
>
> ***
>
> 二者区别：
>
> |      | 数据结构 | 特性         |
> | ---- | -------- | ------------ |
> | DFS  | 栈       | 不具有最短性 |
> | BFS  | 队列     | 最短路径     |
>
> 二者其实根本就是递归



***

DFS例题：

##  排列数字

> ![image-20230129161638035](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230129161638035.png) 
>
> 题目来自于Acwing题库，这是一个比较基础的回溯问题，这里通过DFS深度优先搜索解决
>
> ```java
> import java.util.ArrayList;
> import java.util.List;
> import java.util.Scanner;
> 
> //数字的全排列问题 输入数字n 对于1~n的数字进行排列 输出所有的排列方法
> public class Main {
>  private static int N = 10;//定义一个数字常量
>  private static int[] path = new int[N];//定义一个路径数组 用来保存每一次的路径情况
>  private static boolean[] isUsed = new boolean[N];//定义一个状态数组 标记对应位置上的数字使用使用过
> 
>  public static void main(String[] args) {
>      List<List<Integer>> path = new ArrayList<>();
>      Scanner scanner = new Scanner(System.in);
>      System.out.println("请输入n的值:");
>      int n = scanner.nextInt();
>      DFS(1,n);
>  }
> 
>  private static void DFS(int index,int n) {
>      //DFS 深度优先搜索
>      if(index == n + 1){
>          //如果层次数等于n+1了 就说明这条路径是遍历完了 第一个数字为第一层 后面一次类推
>          //打印path数组中的当前路径
>          for(int i = 0;i < n;i++){
>              System.out.print(path[i] + " ");
>          }
>          System.out.println();
>          return;
>      }
> 
>      //没有搜索到底 就继续往下搜索
>      for(int i = 1;i <= n;i++){
>          //isUsed数组是有多余空间的 所以就直接让数字对应好下标 这样更方便
>          if(!isUsed[i]){
>              //如果当前这个数字还没有用过 那么就可以加入到路径中
>              path[index-1] = i;//path是从下标0开始放元素
>              isUsed[i] = true;//更新状态 这个数字已经用过了
>              DFS(index+1,n);//往深层遍历
>              isUsed[i] = false;//回溯后需要还原 因为这条路径已经走到底了 i这个数字需要重新再去组合下一种情况了
>          }
>      }
>  }
> }
> ```
>
> ![image-20230129200021288](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230129200021288.png)
>
> 
>
> ***
>
> leetcode上的一个相同的题，存在少许的差别
>
> ```java
> import java.util.*;
> class Solution {
>     public List<Integer> path = new ArrayList<>();
>     public Map<Integer,Boolean> map = new HashMap<>();
>     public List<List<Integer>> ret = new ArrayList<>();
> 
>     public void DFS(int[] nums,int index){
>         if(index == nums.length + 1){
>             ret.add(new ArrayList<>(path));
>             return ;
>         }
> 
>         for(int i = 0;i < nums.length;i++){
>             if(!map.get(nums[i])){
>                 path.add(nums[i]);
>                 map.put(nums[i],true);//用了该元素就改变状态
>                 DFS(nums,index + 1);//往下递归
>                 map.put(nums[i],false);//还原状态
>                 path.remove(path.size() - 1);//还原path
>             }
>         }
>     }
>     public List<List<Integer>> permute(int[] nums) {
>         for(int i = 0;i < nums.length;i++){//初始化元素状态 都是没有用过的
>             map.put(nums[i],false);
>         }
>         DFS(nums,1);
>         return ret;
>     }
> }
> ```
>
>  Acwing上的题，用的是数组保存状态，数组保存路径，每次路径添加是直接覆盖值，但是这里用的是arraylist，所以回溯的时候需要还原。

***

##  子集

>[子集](https://leetcode.cn/problems/subsets/description/)
>
>![image-20230129200100006](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230129200100006.png) 
>
>```java
>import java.util.ArrayList;
>import java.util.List;
>
>class Solution {
>    public  List<Integer> path = new ArrayList<>();
>    public  List<List<Integer>> ret = new ArrayList<>();
>
>    public void DFS(int[] nums,int index){
>       ret.add(new ArrayList<>(path));
>       //index表示每一次的起始位置
>       if(index >= nums.length){
>           //终止条件
>           return ;
>       }
>
>       for(int i = index;i < nums.length;i++){
>           path.add(nums[i]);
>           DFS(nums,i+1);
>           path.remove(path.size() - 1);
>       }
>
>    }
>    public List<List<Integer>> subsets(int[] nums) {
>       DFS(nums,0);
>       return ret;
>    }
>}
>```
>
>![image-20230129211216366](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230129211216366.png) 
>
>对于这个题而言，相对于上面那个题，这个就是每个节点上的状态都需要进行保存，但是上面那个只是最后的叶子节点上的终态需要进行保存。

***

##  组合

>[组合](https://leetcode.cn/problems/combinations/description/)
>
>```java
>import java.util.*;
>class Solution {
>public  List<Integer> path = new ArrayList<>();
>public  List<List<Integer>> ret = new ArrayList<>();
>public void DFS(int index,int n,int k){
>
>   if(path.size() == k){
>       ret.add(new ArrayList<>(path));
>       return ;
>   }
>
>   for(int i = index;i <= n;i++){
>       path.add(i);
>       DFS(i+1,n,k);
>       path.remove(path.size() - 1);
>   }
>}
>public List<List<Integer>> combine(int n, int k) {
>   DFS(1,n,k);
>   return ret;
>}
>}
>```
>
>![image-20230131102905567](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230131102905567.png)
>
>其实到这里我们可以发现，我们的递归终止条件与前面的题目都不太一样了，因为这里是组合，对于一个组合而言，只要path长度是k了，就说明这个组合就到底了，需要回溯了。也就是说k限制了树的深度，因为每一层只是取一个元素。
>
>对于我们的回溯题目而言，其实要素就是终止条件，递归，还原这三个点。一般情况下的步骤都是for循环中遍历元素，然后添加元素，往下继续递归，递归返回之后删除末尾元素还原状态。
>
>***
>
>利用剪枝进行优化，只改变内部for循环的边界
>
>```java
>for(int i = index;i <= n - (k - path.size()) + 1;i++){
>    path.add(i);
>    DFS(i+1,n,k);
>    path.remove(path.size() - 1);
>}
>```
>
>重点就是**i <= n - (k - path.size()) + 1**
>
>> 需要取的数的个数是k个，path.size()是当前已经取了的数，那么k - path.size()就是还需要取的数的个数，则n - (k - path.size()) + 1 就是表示前面最多可以取的数的个数
>>
>> 比如 这个题，n = 4，k = 2 ，在第一层上，这个时候也就是path.size()=0，我们在考虑取第一个数，n - (k - path.size()) + 1 = 3，也就是在第一层上，第一个数最多只能取到3，因为到4之后你是取不到k个数了的。

***

##  N皇后问题

> [N皇后](https://leetcode.cn/problems/n-queens/description/)
>
> ```java
> import java.util.*;
> class Solution {
>     public boolean[] col = new boolean[20];//保存列的状态
>     public boolean[] dg = new boolean[20];//保存正对角线的状态
>     public boolean[] undg = new boolean[20];//保存反对角线的状态
>     public List<List<String>> ret = new ArrayList<>();
> 
>     public void DFS(int row,int n,char[][] chessboard){
>         if(row == n){
>             List<String> ret_col = new ArrayList<>();
>             for(char[] tmp : chessboard){
>                 String s = new String(tmp);//这是一行的结果
>                 ret_col.add(s);
>             }
>             ret.add(ret_col);//将整个棋盘的结果存储到ret中
>             return ;
>         }
> 
>         for(int i = 0;i < n;i++){
>             //遍历这一行的每一个位置 看是否可以放
>             if(!col[i] && !dg[row + i] && !undg[n - row + i]){ //进行可行性剪枝，不满足要求的也就不会往下递归
>                 //表示该列 对角线 反对角线上没有皇后 这个位置可以放
>                 chessboard[row][i] = 'Q';//放下皇后
>                 col[i] = dg[row+i] = undg[n-row+i] = true;//更改状态
>                 DFS(row+1,n,chessboard);
>                 col[i] = dg[row+i] = undg[n-row+i] = false;//还原状态 回溯
>                 chessboard[row][i] = '.';
>             }
>         }
>     }
>     public List<List<String>> solveNQueens(int n) {
>         char[][] chessboard = new char[n][n];//定义一个n*n的棋盘
>         for(char[] tmp:chessboard){//初始化棋盘
>             Arrays.fill(tmp,'.');
>         }  
>         DFS(0,n,chessboard);
>         return ret;
>     }
> }
> ```
>
> 这个题目前的解法是属于是暴力列出所有的情况，然后在其中选择符合要求的情况，在每一次往下递归的过程中，如果说某一个递归的过程中如果遍历完了这个一行的每一个位置都找不到一个符合要求的位置那么for循环就结束了，整个递归的深度也就到此了，开始返回，所以最后ret中也不会存储到任何结果。只有当row == n的时候，说明这是递归到底了，并且目前是整个棋盘皇后都放好了这是一种解法，所以就可以存储到ret中了。
>
> 这里可能有的同学不太理解状态的存储，每一行我们是一次递归，所以肯定是只放了一次，列也好说，主要是对角线上，怎么下标对应上的
>
> ![image-20230131155633541](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230131155633541.png) 
>
> 

> 还有一种更普通的解决办法就是一个格子一个格子的考虑，每个格子只有两种情况，放或者不放，枚举完所有格子的所有情况
>
> ```java
> import java.util.*;
> class Solution {
>     public boolean[] col = new boolean[20];//保存列的状态
>     public boolean[] dg = new boolean[20];//保存正对角线的状态
>     public boolean[] undg = new boolean[20];//保存反对角线的状态
>     public boolean[] row = new boolean[20];//保存行的状态
>     public List<List<String>> ret = new ArrayList<>();
> 
>     public void DFS(int x,int y,int count,int n,char[][] chessboard){
>         //按每一个格子进行枚举
>         if(y == n){
>             //说明已经到了最右边格子了 需要跳到下一行搜索
>             y = 0;
>             x++;
>         }
> 
>         if(x == n){
>             //说明已经搜索到底
>             if(count == n){
>                 //说明已经全部搜索完毕 并且放入了n个皇后 也就是一种可行的解法
>                 //存储结果
>                 List<String> ret_col = new ArrayList<>();
>                 for(char[] tmp : chessboard){
>                     String s = new String(tmp);//这是一行的结果
>                     ret_col.add(s);
>                 }
>                 ret.add(ret_col);//将整个棋盘的结果存储到ret中
>                 
>             }
>             return ;//注意这个return的位置 不要放到里面if中去了
>         }
> 
>         //否则就是继续往下一个格子搜索 每个格子有两种情况 放或不放
>         //不放
>         DFS(x,y + 1,count,n,chessboard);
>         //放
>         if(!row[x] && !col[y] && !dg[x + y] && !undg[n - x + y]){
>             chessboard[x][y] = 'Q';//放下皇后
>             row[x] = col[y] = dg[x + y] = undg[n-x+y] = true;//更改状态
>             DFS(x,y+1,count + 1,n,chessboard);
>             row[x] = col[y] = dg[x + y] = undg[n-x+y] = false;//还原状态 回溯
>             chessboard[x][y] = '.';
>         }
>     }
> 
>     public List<List<String>> solveNQueens(int n) {
>         char[][] chessboard = new char[n][n];//定义一个n*n的棋盘
>         for(char[] tmp:chessboard){//初始化棋盘
>             Arrays.fill(tmp,'.');
>         }  
>         DFS(0,0,0,n,chessboard);
>         return ret;
>     }
> }
> ```
>
> 这种方法求解的话，就是按照格子枚举，相对于按照行枚举，情况就会更多，复杂度也更高。每个格子都是两个分支，整体看下来就是一个满二叉树
>
> ![image-20230201124034304](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20230201124034304.png) 
>
> 首先都是假设都不放然后一直递归到底，在回溯的过程中开始放，中间可能会出现满足要求的情况。第一个格子不放往下的情况递归完，和第一个格子放往下的情况递归完，最终就得到了结果。不过这种方式因为是以每一个格子为基准，所以就需要再用一个数组来保存每一行的状态了，前面第一种方法因为是以行进行枚举，所以一行肯定就是只会放一个。

