#  多线程(进阶)

#  一，常见锁策略

##  1.1，乐观锁，悲观锁

乐观锁：假设数据一般情况下不会出现并发冲突，所以在对数据进行操作的时候，会直接去操作，然后在操作完对数据进行提交的时候(写回内存)，再通过一定的机制来验证数据是否存在了冲突。

悲观锁：总是假设最坏的情况，就是总是存在并发冲突的问题，所以每次操作都是先尝试加锁后再进行操作。

***

synchronized初始使用乐观锁策略，在发现锁竞争比较频繁的时候，就会自动切换成悲观锁策略。初始使用乐观锁策略，如果真的恰好没有冲突存在，那么就直接减去了加锁的步骤，可以节省一定的时间和资源，直至乐观锁尝试提交数据几次都失败发现存在冲突的时候，这个时候再调整为悲观锁策略，去加锁进行处理。

***

那么，乐观锁是如何检测到存在访问冲突的呢，这里引入一个版本号来进行标识。

![image-20220922093412312](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220922093412312.png) 



****

##  1.2，读写锁，普通互斥锁

普通互斥锁。例如我们的sunchronized，只要是多个线程之间竞争同一把锁，那么就会有锁竞争，从而产生阻塞等待。

而读写锁相对于普通的互斥锁，会根据你的操作意图(读or写)来决定。读写锁存在两种加锁情况，加读锁和加写锁。例如：

1，多个线程同时进行读数据，直接读取即可，也就是读锁与读锁之间不会存在互斥的问题。【不存在线程安全问题】

2，多个线程同时进行修改数据，需要互斥进行操作，也就是写锁与写锁之间会存在锁竞争。【存在线程安全问题】

3，多个线程，有的读取数据，有的修改数据，需要互斥进行操作，也就是读锁与写锁之间存在竞争。【存在线程安全问题】

***

读写锁的机制就相当于是把读操作与写操作区分对待了。在实际的开发环境中，其实大部分情况下读的操作场景会多于写的操作场景，所以利用读写锁，就可以减少大量的锁竞争，优化了效率。

***

##  1.3，重量级锁，轻量级锁

![image-20220922102532385](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220922102532385.png) 

***

##  1.4，自旋锁，挂起等待锁

自旋锁：循环的尝试加锁，无限循环，直至获取到锁为止。获取锁会很及时，但是这个时候CPU的占用率就比较高。

挂起等待锁：尝试获取锁失败之后，就会挂起等待，之后再尝试进行加锁。这个时候CPU占用率就比较低，可以去做别的事情，之后再来获取锁，只是相对于自旋锁可能没有那么及时的获取到锁。

***

自旋锁是轻量级锁的一种典型实现，挂起等待锁是重量级锁的一种典型实现



***

##  1.5，公平锁，非公平锁

公平锁与非公平锁，首先这里先要颠覆大家对于公平的定义，这里什么叫做公平：那就是先到先得，讲究一个先来后到。

公平锁：先到的线程则先获取到锁，后到的线程则后面才能获取到。

非公平锁：不遵守先来后到，先到的与后到的线程都有同等的机会获取到锁。

***

操作系统默认的随机调度，也就是非公平锁，如果想要实现公平锁，需要依赖额外的数据结构来实现。

***

##  1.6，可重入锁，不可重入锁

同一个线程针对同一把锁连续加锁两次，会造成死锁的是不可重入锁，不会死锁的是可重入锁。

***

##  1.7，synchronized总结

![image-20220922120213177](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220922120213177.png) 

***

synchronized这种智能的调整机制是JVM为我们实现好的自动优化策略，用来适应不同的场景。

***

#  二，CAS

CAS：全称就是 compare and swap，比较与交换的意思，它可以完成变量在满足条件下进行赋值的同时保证这是一个原子性的操作即线程安全。

操作机制：

把内存中的值val和CPU寄存器A中的值进行比较，如果值相等(也就是满足条件)，就把另一个寄存器B中的值和内存中的值val进行交换。其实这里的核心就是赋值是利用交换实现的，我们的目的就是将寄存器B中的值放到内存中，也就是赋值操作。

上述的这个操作是一个硬件指令完成的，所以也就是线程安全的。并且相对于加锁，CAS的开销也小一些。但是CAS的使用面肯定是比加锁要小很多的。

***

